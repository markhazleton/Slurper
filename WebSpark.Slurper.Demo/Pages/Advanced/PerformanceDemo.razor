@page "/advanced/performance"
@using WebSpark.Slurper
@using System.Dynamic
@using System.Text.Json
@using System.Text
@using System.Diagnostics
@using System.Threading
@inject HttpClient Http

<PageTitle>Slurper - Performance Demo</PageTitle>

<div class="container">
    <div class="row mt-4">
        <div class="col-md-12">
            <h1>Performance Features Demo</h1>
            <p class="lead">
                Explore Slurper's performance optimization capabilities for working with large datasets.
            </p>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-md-12">
            <div class="card mb-4">
                <div class="card-header bg-primary text-white">
                    <h4>Performance Options</h4>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="useStreaming" @bind="useStreaming">
                                <label class="form-check-label" for="useStreaming">
                                    <strong>Use Streaming</strong>
                                </label>
                                <div class="form-text">Process data as it arrives instead of loading everything into
                                    memory</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="useParallel" @bind="useParallel">
                                <label class="form-check-label" for="useParallel">
                                    <strong>Enable Parallel Processing</strong>
                                </label>
                                <div class="form-text">Process data using multiple CPU cores when possible</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="useCaching" @bind="useCaching">
                                <label class="form-check-label" for="useCaching">
                                    <strong>Enable Caching</strong>
                                </label>
                                <div class="form-text">Cache repeated operations to improve performance</div>
                            </div>
                        </div>
                    </div>

                    <div class="row mt-3">
                        <div class="col-md-4">
                            <div class="mb-3">
                                <label for="dataSize" class="form-label"><strong>Data Size</strong></label>
                                <select class="form-select" id="dataSize" @bind="dataSize">
                                    <option value="small">Small (Simple Data)</option>
                                    <option value="medium">Medium (1000 Items)</option>
                                    <option value="large">Large (10,000 Items)</option>
                                </select>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="mb-3">
                                <label for="dataFormat" class="form-label"><strong>Data Format</strong></label>
                                <select class="form-select" id="dataFormat" @bind="dataFormat">
                                    <option value="json">JSON</option>
                                    <option value="xml">XML</option>
                                </select>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="mb-3">
                                <label for="iterations" class="form-label"><strong>Test Iterations</strong></label>
                                <input type="number" class="form-control" id="iterations" @bind="iterations" min="1"
                                    max="10">
                            </div>
                        </div>
                    </div>

                    <div class="d-grid gap-2 mt-3">
                        <button class="btn btn-primary" @onclick="RunPerformanceTest" disabled="@isRunning">
                            @if (isRunning)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span> Running Test...</span>
                            }
                            else
                            {
                                <span>Run Performance Test</span>
                            }
                        </button>
                    </div>
                </div>
            </div>

            <div class="card mb-4">
                <div class="card-header bg-success text-white">
                    <h4>Performance Results</h4>
                </div>
                <div class="card-body">
                    @if (isRunning)
                    {
                        <div class="text-center p-4">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p class="mt-2">Running performance test...</p>
                            <div class="progress mt-3">
                                <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar"
                                    style="width: @($"{progressPercentage}%")">
                                    @progressPercentage%
                                </div>
                            </div>
                        </div>
                    }
                    else if (testResults.Count > 0)
                    {
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>Test Configuration</th>
                                        <th>Average Time (ms)</th>
                                        <th>Memory Used (MB)</th>
                                        <th>Items Processed</th>
                                        <th>Items/Second</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var result in testResults)
                                    {
                                        <tr>
                                            <td>
                                                <strong>@result.Name</strong><br />
                                                <small class="text-muted">
                                                    Streaming: @(result.UseStreaming ? "Yes" : "No") |
                                                    Parallel: @(result.UseParallel ? "Yes" : "No") |
                                                    Caching: @(result.UseCaching ? "Yes" : "No")
                                                </small>
                                            </td>
                                            <td>@result.AverageTime.ToString("F2")</td>
                                            <td>@result.MemoryUsed.ToString("F2")</td>
                                            <td>@result.ItemsProcessed.ToString("N0")</td>
                                            <td>@result.ItemsPerSecond.ToString("N0")</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </div>

                        @if (testResults.Count > 1)
                        {
                            <div class="mt-4">
                                <h5>Performance Comparison</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header">Processing Time Comparison</div>
                                            <div class="card-body">
                                                @foreach (var result in testResults)
                                                {
                                                    <div class="mb-2">
                                                        <div>@result.Name (@result.AverageTime.ToString("F2") ms)</div>
                                                        <div class="progress">
                                                            <div class="progress-bar bg-info" role="progressbar"
                                                                style="width: @($"{(result.AverageTime / testResults.Max(r => r.AverageTime) * 100).ToString("F0")}%")">
                                                            </div>
                                                        </div>
                                                    </div>
                                                }
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header">Memory Usage Comparison</div>
                                            <div class="card-body">
                                                @foreach (var result in testResults)
                                                {
                                                    <div class="mb-2">
                                                        <div>@result.Name (@result.MemoryUsed.ToString("F2") MB)</div>
                                                        <div class="progress">
                                                            <div class="progress-bar bg-warning" role="progressbar"
                                                                style="width: @($"{(result.MemoryUsed / testResults.Max(r => r.MemoryUsed) * 100).ToString("F0")}%")">
                                                            </div>
                                                        </div>
                                                    </div>
                                                }
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    }
                    else
                    {
                        <div class="alert alert-info">
                            <p>Configure your performance test options and click "Run Performance Test" to see the results.
                            </p>
                            <p>The test will show how different configuration options impact:</p>
                            <ul>
                                <li><strong>Processing Time</strong>: How quickly Slurper can process the data</li>
                                <li><strong>Memory Usage</strong>: How much memory is required during processing</li>
                                <li><strong>Throughput</strong>: How many items can be processed per second</li>
                            </ul>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header bg-dark text-white">
                    <h4>How Performance Options Work</h4>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <div class="card h-100">
                                <div class="card-header bg-light">
                                    <h5>Streaming</h5>
                                </div>
                                <div class="card-body">
                                    <p>Slurper's streaming option allows processing data as it's received, instead of
                                        loading the entire document into memory:</p>
                                    <pre><code class="language-csharp">var options = new SlurperOptions
{
    UseStreaming = true
};

var result = await extractor.ExtractFromFileAsync(
    "large-data.xml", 
    options
);</code></pre>
                                    <p class="mt-3"><strong>Best for:</strong> Very large documents, memory-constrained
                                        environments, processing files larger than available RAM.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card h-100">
                                <div class="card-header bg-light">
                                    <h5>Parallel Processing</h5>
                                </div>
                                <div class="card-body">
                                    <p>Enables processing multiple parts of a document concurrently using all available
                                        CPU cores:</p>
                                    <pre><code class="language-csharp">var options = new SlurperOptions
{
    EnableParallelProcessing = true
};

var result = extractor.Extract(
    jsonData, 
    options
);</code></pre>
                                    <p class="mt-3"><strong>Best for:</strong> Documents with many independent nodes,
                                        multi-core systems, CPU-bound operations, batch processing.</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card h-100">
                                <div class="card-header bg-light">
                                    <h5>Caching</h5>
                                </div>
                                <div class="card-body">
                                    <p>Caches intermediate results to speed up repeated operations and property access:
                                    </p>
                                    <pre><code class="language-csharp">var options = new SlurperOptions
{
    EnableCaching = true
};

var result = extractor.Extract(
    xmlData, 
    options
);</code></pre>
                                    <p class="mt-3"><strong>Best for:</strong> Repeated access to the same properties,
                                        complex documents with many references to the same objects, deep object graphs.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    // Performance test options
    private bool useStreaming = false;
    private bool useParallel = false;
    private bool useCaching = false;
    private string dataSize = "small";
    private string dataFormat = "json";
    private int iterations = 3;

    // Test state
    private bool isRunning = false;
    private int progressPercentage = 0;
    private List<PerformanceResult> testResults = new();

    public class PerformanceResult
    {
        public string Name { get; set; } = string.Empty;
        public bool UseStreaming { get; set; }
        public bool UseParallel { get; set; }
        public bool UseCaching { get; set; }
        public double AverageTime { get; set; }
        public double MemoryUsed { get; set; }
        public int ItemsProcessed { get; set; }
        public int ItemsPerSecond { get; set; }
    }

    private async Task RunPerformanceTest()
    {
        isRunning = true;
        progressPercentage = 0;

        try
        {
            // Clear previous results if running a new test
            testResults.Clear();

            // Run the test with current options
            var currentTestResult = await RunTestWithCurrentOptions();
            testResults.Add(currentTestResult);

            // If there's time and the user didn't select all options, run an optimized test for comparison
            if (!useStreaming || !useParallel || !useCaching)
            {
                progressPercentage = 50;

                var optimizedResult = await RunOptimizedTest();
                testResults.Add(optimizedResult);
            }

            progressPercentage = 100;
            await Task.Delay(500); // Brief delay to show 100% progress
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in performance test: {ex.Message}");
        }
        finally
        {
            isRunning = false;
        }
    }

    private async Task<PerformanceResult> RunTestWithCurrentOptions()
    {
        // Generate sample data based on selected size and format
        string testData = await GenerateTestData();

        // Set up the options
        var options = new SlurperOptions
        {
            UseStreaming = useStreaming,
            EnableParallelProcessing = useParallel,
            EnableCaching = useCaching
        };

        // Create the factory and get the appropriate extractor
        var factory = new SlurperFactory();

        // Run multiple iterations and measure performance
        var stopwatch = new Stopwatch();
        long totalMemoryBefore = GC.GetTotalMemory(true);
        int itemsProcessed = 0;

        List<long> testTimes = new List<long>();

        for (int i = 0; i < iterations; i++)
        {
            // Update progress
            progressPercentage = (int)(((double)i / (iterations * 2)) * 100);

            // Force garbage collection before test
            GC.Collect();
            GC.WaitForPendingFinalizers();

            // Start timing
            stopwatch.Restart();

            // Run the extraction
            dynamic result;
            if (dataFormat == "json")
            {
                var jsonExtractor = factory.CreateJsonExtractor();
                result = SlurperHelper.Extract(jsonExtractor, testData, options);
            }
            else // xml
            {
                var xmlExtractor = factory.CreateXmlExtractor();
                result = SlurperHelper.Extract(xmlExtractor, testData, options);
            }

            // Stop timing
            stopwatch.Stop();
            testTimes.Add(stopwatch.ElapsedMilliseconds);

            // Count items processed (simplified estimate)
            itemsProcessed = EstimateItemsProcessed(result);

            // Brief delay to allow UI updates
            await Task.Delay(100);
        }

        // Calculate memory usage
        long totalMemoryAfter = GC.GetTotalMemory(false);
        double memoryUsedMB = (totalMemoryAfter - totalMemoryBefore) / (1024.0 * 1024.0);

        // Calculate average time
        double averageTime = testTimes.Average();

        // Calculate items per second
        int itemsPerSecond = (int)(itemsProcessed / (averageTime / 1000.0));

        // Create result
        return new PerformanceResult
        {
            Name = $"Custom Configuration ({dataSize} {dataFormat})",
            UseStreaming = useStreaming,
            UseParallel = useParallel,
            UseCaching = useCaching,
            AverageTime = averageTime,
            MemoryUsed = memoryUsedMB > 0 ? memoryUsedMB : 0.1, // Ensure positive value for display
            ItemsProcessed = itemsProcessed,
            ItemsPerSecond = itemsPerSecond
        };
    }

    private async Task<PerformanceResult> RunOptimizedTest()
    {
        // Generate sample data again
        string testData = await GenerateTestData();

        // Set up optimized options
        var optimizedOptions = new SlurperOptions
        {
            UseStreaming = dataSize == "large", // Streaming for large data
            EnableParallelProcessing = true, // Always use parallel for optimized
            EnableCaching = true // Always use caching for optimized
        };

        // Create the factory and get the appropriate extractor
        var factory = new SlurperFactory();

        // Run multiple iterations and measure performance
        var stopwatch = new Stopwatch();
        long totalMemoryBefore = GC.GetTotalMemory(true);
        int itemsProcessed = 0;

        List<long> testTimes = new List<long>();

        for (int i = 0; i < iterations; i++)
        {
            // Update progress
            progressPercentage = 50 + (int)(((double)i / (iterations * 2)) * 100);

            // Force garbage collection before test
            GC.Collect();
            GC.WaitForPendingFinalizers();

            // Start timing
            stopwatch.Restart();

            // Run the extraction
            dynamic result;
            if (dataFormat == "json")
            {
                var jsonExtractor = factory.CreateJsonExtractor();
                result = SlurperHelper.Extract(jsonExtractor, testData, optimizedOptions);
            }
            else // xml
            {
                var xmlExtractor = factory.CreateXmlExtractor();
                result = SlurperHelper.Extract(xmlExtractor, testData, optimizedOptions);
            }

            // Stop timing
            stopwatch.Stop();
            testTimes.Add(stopwatch.ElapsedMilliseconds);

            // Count items processed (simplified estimate)
            itemsProcessed = EstimateItemsProcessed(result);

            // Brief delay to allow UI updates
            await Task.Delay(100);
        }

        // Calculate memory usage
        long totalMemoryAfter = GC.GetTotalMemory(false);
        double memoryUsedMB = (totalMemoryAfter - totalMemoryBefore) / (1024.0 * 1024.0);

        // Calculate average time
        double averageTime = testTimes.Average();

        // Calculate items per second
        int itemsPerSecond = (int)(itemsProcessed / (averageTime / 1000.0));

        // Create result
        return new PerformanceResult
        {
            Name = $"Optimized Configuration ({dataSize} {dataFormat})",
            UseStreaming = optimizedOptions.UseStreaming,
            UseParallel = optimizedOptions.EnableParallelProcessing,
            UseCaching = optimizedOptions.EnableCaching,
            AverageTime = averageTime,
            MemoryUsed = memoryUsedMB > 0 ? memoryUsedMB : 0.1, // Ensure positive value for display
            ItemsProcessed = itemsProcessed,
            ItemsPerSecond = itemsPerSecond
        };
    }

    private async Task<string> GenerateTestData()
    {
        // For simplicity in this demo, we'll generate synthetic data
        // In a real-world scenario, you might load this from a file or API

        // Number of items based on selected size
        int itemCount = dataSize switch
        {
            "small" => 10,
            "medium" => 1000,
            "large" => 10000,
            _ => 10
        };

        if (dataFormat == "json")
        {
            // Generate a JSON array of items
            var items = new List<object>();
            for (int i = 0; i < itemCount; i++)
            {
                items.Add(new
                {
                    id = i,
                    name = $"Item {i}",
                    price = 10.99 + (i % 10),
                    inStock = i % 3 == 0,
                    tags = new[] { "tag1", "tag2", "tag3" },
                    details = new
                    {
                        color = i % 2 == 0 ? "Red" : "Blue",
                        weight = 1.5 + (i * 0.1),
                        dimensions = new
                        {
                            width = 10 + (i % 5),
                            height = 20 + (i % 3),
                            depth = 5 + (i % 2)
                        }
                    }
                });
            }

            return JsonSerializer.Serialize(new { items });
        }
        else // xml
        {
            // For simplicity in the demo, we'll just use a string builder instead of proper XML generation
            var sb = new StringBuilder();
            sb.AppendLine("<?xml version=\"1.0\" encoding=\"utf-8\" ?>");
            sb.AppendLine("<catalog>");

            for (int i = 0; i < itemCount; i++)
            {
                sb.AppendLine($" <item id=\"{i}\">");
                sb.AppendLine($" <name>Item {i}</name>");
                sb.AppendLine($" <price>{10.99 + (i % 10)}</price>");
                sb.AppendLine($" <inStock>{(i % 3 == 0 ? "true" : "false")}</inStock>");
                sb.AppendLine(" <tags>");
                sb.AppendLine(" <tag>tag1</tag>");
                sb.AppendLine(" <tag>tag2</tag>");
                sb.AppendLine(" <tag>tag3</tag>");
                sb.AppendLine(" </tags>");
                sb.AppendLine(" <details>");
                sb.AppendLine($" <color>{(i % 2 == 0 ? "Red" : "Blue")}</color>");
                sb.AppendLine($" <weight>{1.5 + (i * 0.1)}</weight>");
                sb.AppendLine(" <dimensions>");
                sb.AppendLine($" <width>{10 + (i % 5)}</width>");
                sb.AppendLine($" <height>{20 + (i % 3)}</height>");
                sb.AppendLine($" <depth>{5 + (i % 2)}</depth>");
                sb.AppendLine(" </dimensions>");
                sb.AppendLine(" </details>");
                sb.AppendLine(" </item>");
            }

            sb.AppendLine("</catalog>");
            return sb.ToString();
        }
    }

    private int EstimateItemsProcessed(dynamic result)
    {
        try
        {
            // This is a simplified estimate for the demo
            if (dataFormat == "json")
            {
                if (result.items != null)
                {
                    return result.items.Count;
                }
            }
            else // xml
            {
                if (result.catalog != null && result.catalog.itemList != null)
                {
                    return result.catalog.itemList.Count;
                }
            }
        }
        catch
        {
            // Fallback to size-based estimate
            return dataSize switch
            {
                "small" => 10,
                "medium" => 1000,
                "large" => 10000,
                _ => 10
            };
        }

        return 0;
    }
}
